using System.Diagnostics;
using Godot;
using Godot.Collections;

namespace PrettyDunGen3D;

// TODO PathColor synchronizatrion if a rule changed its color.
[Tool]
public partial class PrettyDunGen3DChunk : Node3D
{
    /// <summary>
    /// Coordinates of this chunk assigned by the generator (Coordinates are distributed like a grid)
    /// </summary>
    [ExportGroup("Generated Values (Debugging)")]
    [Export]
    public Vector3I Coordinates { get; private set; }

    /// <summary>
    /// World-space size of this chunk.
    /// </summary>
    [Export]
    public Vector3 Size { get; set; }

    /// <summary>
    /// Category tags assigned to this chunk (e.g. "start", "boss", "treasure").
    /// </summary>
    [Export]
    public Array<string> Categories { get; private set; } = new();

    /// <summary>
    /// Neighbouring chunks as determined by the current graph connectivity.
    /// </summary>
    [Export]
    public Array<PrettyDunGen3DChunk> Neighbours { get; private set; } = new();

    [Export]
    public Array<PrettyDunGen3DChunkConnector> Connectors { get; private set; } = new();

    [Export]
    public Vector3 NeighbourForwardDistance { get; private set; }

    [Export]
    public Vector3 NeighbourBackDistance { get; private set; }

    [Export]
    public Vector3 NeighbourRightDistance { get; private set; }

    [Export]
    public Vector3 NeighbourLeftDistance { get; private set; }

    [Export]
    public Vector3 NeighbourUpDistance { get; private set; }

    [Export]
    public Vector3 NeighbourDownDistance { get; private set; }

    /// <summary>
    /// The generator instance that owns this chunk.
    /// </summary>
    [Export]
    public PrettyDunGen3DGenerator Generator { get; private set; }

    [Export]
    public Color PathDebugColor { get; set; } = new Color(1f, 0f, 0f, 1f);

    [Export]
    public Color ChunkDebugColor { get; set; } = new Color(0f, 0.2f, 1f, 1f);

    public PrettyDunGen3DChunk(PrettyDunGen3DGenerator generator, Vector3I coordinates)
    {
        Generator = generator;
        Coordinates = coordinates;
        ChunkDebugColor = Generator.ChunkDebugColor;
    }

    // Default Constructor should not be used. The Node is generated by PrettyGraph/PrettyDunGenGenerator
    // Just here to provide a way for Godot to create this Node e.g. when recompiling
    public PrettyDunGen3DChunk() { }

    MeshInstance3D debugMeshInstance3D;

    public override void _Ready()
    {
        // Needed to detect changes, when the chunk is resized or moved
        SetNotifyTransform(true);
    }

    public override void _Process(double delta)
    {
        if (Engine.IsEditorHint())
            DrawDebug();
    }

    public override void _Notification(int what)
    {
        if (what == NotificationTransformChanged)
            UpdateNeighbourDistances();
    }

    /// <summary>
    /// Adds a category tag to this chunk.
    /// <see langword="true"/> if the category was added; <see langword="false"/> if it already existed.
    /// </returns>
    public bool AddCategory(string category)
    {
        if (Categories.Contains(category))
            return false;

        Categories.Add(category);
        Generator.InformChunkCategoryChanged(this);
        return true;
    }

    /// <summary>
    /// Checks whether this chunk has the given category tag.
    /// </summary>
    /// <returns><see langword="true"/> if the tag exists; otherwise <see langword="false"/>.</returns>
    public bool ContainsCategory(string category) => Categories.Contains(category);

    /// <summary>
    /// Removes a category tag from this chunk.
    /// </summary>
    /// <returns>
    /// <see langword="true"/> if the category was removed; <see langword="false"/> if it was not present.
    /// </returns>
    public bool RemoveCategory(string category)
    {
        if (Categories.Remove(category))
        {
            Generator.InformChunkCategoryChanged(this);
            return true;
        }
        return false;
    }

    // Note the distance between two chunks is always equal to chunkA.offset + chunkb.offset
    public void Resize(Vector3 size, Vector3 offset)
    {
        Size = size;
        Position = Coordinates * (size + offset) + (Vector3)Coordinates * offset;
    }

    public Vector3 GetDistanceVectorTo(PrettyDunGen3DChunk chunk)
    {
        Vector3 combinedHalfExtent = chunk.Size * 0.5f + Size * 0.5f;
        Vector3 deltaDir = chunk.GlobalPosition - GlobalPosition;

        return deltaDir.Sign() * (deltaDir.Abs() - combinedHalfExtent);
    }

    public Vector3 GetConnectionCenter(PrettyDunGen3DChunk neighbour, bool local = false)
    {
        Vector3 distance = GetDistanceVectorTo(neighbour);
        Vector3 halfExtent = Size * 0.5f;

        if (local)
            return (halfExtent * distance.Sign()) + distance * 0.5f;

        return GlobalPosition + (halfExtent * distance.Sign()) + distance * 0.5f;
    }

    private void UpdateNeighbourDistances()
    {
        NeighbourForwardDistance = Vector3.Zero;
        NeighbourBackDistance = Vector3.Zero;
        NeighbourRightDistance = Vector3.Zero;
        NeighbourLeftDistance = Vector3.Zero;
        NeighbourUpDistance = Vector3.Zero;
        NeighbourDownDistance = Vector3.Zero;

        foreach (var neighbour in Neighbours)
        {
            if (neighbour.Coordinates - Coordinates == Vector3.Forward)
            {
                NeighbourForwardDistance = GetDistanceVectorTo(neighbour);
                // Neighbour also needs to know about the change.
                neighbour.NeighbourBackDistance = neighbour.GetDistanceVectorTo(this);
            }
            else if (neighbour.Coordinates - Coordinates == Vector3.Back)
            {
                NeighbourBackDistance = GetDistanceVectorTo(neighbour);
                neighbour.NeighbourForwardDistance = neighbour.GetDistanceVectorTo(this);
            }
            else if (neighbour.Coordinates - Coordinates == Vector3.Right)
            {
                NeighbourRightDistance = GetDistanceVectorTo(neighbour);
                neighbour.NeighbourLeftDistance = neighbour.GetDistanceVectorTo(this);
            }
            else if (neighbour.Coordinates - Coordinates == Vector3.Left)
            {
                NeighbourLeftDistance = GetDistanceVectorTo(neighbour);
                neighbour.NeighbourRightDistance = neighbour.GetDistanceVectorTo(this);
            }
            else if (neighbour.Coordinates - Coordinates == Vector3.Up)
            {
                NeighbourUpDistance = GetDistanceVectorTo(neighbour);
                neighbour.NeighbourDownDistance = neighbour.GetDistanceVectorTo(this);
            }
            else if (neighbour.Coordinates - Coordinates == Vector3.Down)
            {
                NeighbourDownDistance = GetDistanceVectorTo(neighbour);
                neighbour.NeighbourUpDistance = neighbour.GetDistanceVectorTo(this);
            }
        }
    }

    /// <summary>
    /// Synchronizes inspector-visible data with the current graph state.
    /// Called automatically by the graph when it adds a node or an edge.
    /// </summary>
    public void SyncWithGraph(PrettyDunGen3DGraph graph)
    {
        Neighbours.Clear();
        Neighbours.AddRange(graph.GetNeighbours(this));
        SyncChunk();
    }

    // Syncs with attached connectors. Should be called after  a chunk is moved or resized,
    // So that connectors can reevalute there positon.
    public void SyncChunk()
    {
        foreach (var connector in Connectors)
        {
            connector.GenerateSize();
            connector.UpdateConnectionCenter();
        }
    }

    // Adds a Connector that represents a connection between this chunk and another chunk
    // Created by Graph AddEdge...
    public bool AddConnector(PrettyDunGen3DChunkConnector connector)
    {
        if (!connector.IsConnectedToChunk(this))
            return false;

        if (!Connectors.Contains(connector))
            Connectors.Add(connector);

        return true;
    }

    public PrettyDunGen3DChunkConnector GetConnector(PrettyDunGen3DChunk chunk)
    {
        foreach (var connector in Connectors)
        {
            if (connector.IsConnectedToChunk(chunk))
                return connector;
        }

        return null;
    }

    private void DrawDebug()
    {
        if (!Engine.IsEditorHint())
            return;
        if (Generator == null)
            return;
        if (Generator.Graph == null)
            return;
        if (!Generator.ShowDebug)
            return;

        var graph = Generator.Graph;

        // Draw Chunk
        DebugDraw3D.DrawText(GlobalPosition - Vector3.One, "INDEX: " + graph.GetIndexOf(this), 64);
        DebugDraw3D.ScopedConfig().SetThickness(0.05f);
        DebugDraw3D.DrawBox(GlobalPosition, Quaternion.Identity, Size, ChunkDebugColor, true);
        DebugDraw3D.ScopedConfig().SetThickness(0.05f);

        // CENTER BOX
        DebugDraw3D.DrawBox(
            GlobalPosition,
            Quaternion.Identity,
            Vector3.One,
            ChunkDebugColor,
            true
        );
    }
}
