using Godot;
using Godot.Collections;

namespace PrettyDunGen3D;

// TODO PathColor synchronizatrion if a rule changed its color.
[Tool]
public partial class PrettyDunGen3DChunk : Node3D
{
    /// <summary>
    /// Coordinates of this chunk assigned by the generator (Coordinates are distributed like a grid)
    /// </summary>
    [ExportGroup("Generated Values (Debugging)")]
    [Export]
    public Vector3I Coordinates { get; private set; }

    /// <summary>
    /// World-space size of this chunk.
    /// </summary>
    [Export]
    public Vector3 Size { get; set; }

    /// <summary>
    /// Category tags assigned to this chunk (e.g. "start", "boss", "treasure").
    /// </summary>
    [Export]
    public Array<string> Categories { get; private set; } = new();

    /// <summary>
    /// Neighbouring chunks as determined by the current graph connectivity.
    /// </summary>
    [Export]
    public Array<PrettyDunGen3DChunk> Neighbours { get; private set; } = new();

    /// <summary>
    /// The generator instance that owns this chunk.
    /// </summary>
    [Export]
    public PrettyDunGen3DGenerator Generator { get; private set; }

    [Export]
    public Color PathDebugColor = new Color(1f, 0f, 0f, 1f);

    [Export]
    public Color ChunkDebugColor = new Color(0f, 0f, 0f, 1f);

    public PrettyDunGen3DChunk(PrettyDunGen3DGenerator generator, Vector3I coordinates)
    {
        Generator = generator;
        Coordinates = coordinates;
        ChunkDebugColor = Generator.ChunkDebugColor;
    }

    // Default Constructor should not be used. The Node is generated by PrettyDunGen3DGenerator
    // Just here to provide a way for Godot to create this Node (Im unsure if this is needed though).
    public PrettyDunGen3DChunk() { }

    MeshInstance3D debugMeshInstance3D;

    public override void _PhysicsProcess(double delta)
    {
        if (Engine.IsEditorHint())
            DrawDebug();
    }

    /// <summary>
    /// Adds a category tag to this chunk.
    /// <see langword="true"/> if the category was added; <see langword="false"/> if it already existed.
    /// </returns>
    public bool AddCategory(string category)
    {
        if (Categories.Contains(category))
            return false;

        Categories.Add(category);
        Generator.InformChunkCategoryChanged(this);
        return true;
    }

    /// <summary>
    /// Checks whether this chunk has the given category tag.
    /// </summary>
    /// <returns><see langword="true"/> if the tag exists; otherwise <see langword="false"/>.</returns>
    public bool ContainsCategory(string category) => Categories.Contains(category);

    /// <summary>
    /// Removes a category tag from this chunk.
    /// </summary>
    /// <returns>
    /// <see langword="true"/> if the category was removed; <see langword="false"/> if it was not present.
    /// </returns>
    public bool RemoveCategory(string category)
    {
        if (Categories.Remove(category))
        {
            Generator.InformChunkCategoryChanged(this);
            return true;
        }
        return false;
    }

    /// <summary>
    /// Synchronizes inspector-visible data with the current graph state.
    /// Called automatically by the graph when it adds a node or an edge.
    /// </summary>
    public void SyncWithGraph(PrettyDunGen3DGraph graph)
    {
        // Workaround to show Neighbours in inspector. (Can not be readonly unfortunately)
        Neighbours.Clear();
        Neighbours.AddRange(graph.GetNeighbours(this));
    }

    private void DrawDebug()
    {
        if (!Engine.IsEditorHint())
            return;
        if (Generator == null)
            return;
        if (Generator.Graph == null)
            return;
        if (!Generator.ShowDebug)
            return;

        var graph = Generator.Graph;

        // Draw Chunk
        DebugDraw3D.ScopedConfig().SetThickness(0.2f);
        DebugDraw3D.DrawBox(GlobalPosition, Quaternion.Identity, Size, ChunkDebugColor, true);

        // Draw Edges
        foreach (PrettyDunGen3DChunk neighbour in Neighbours)
        {
            // Drawing Order. Only draw when chunk was created later in the graph.
            if (graph.GetIndexOf(this) < graph.GetIndexOf(neighbour))
                continue;

            DebugDraw3D.ScopedConfig().SetThickness(0.1f);
            DebugDraw3D.DrawBox(
                GlobalPosition,
                Quaternion.Identity,
                Vector3.One,
                PathDebugColor,
                true
            );
            DebugDraw3D.DrawBox(
                neighbour.GlobalPosition,
                Quaternion.Identity,
                Vector3.One,
                PathDebugColor,
                true
            );
            DebugDraw3D.ScopedConfig().SetThickness(0.2f);
            DebugDraw3D.DrawLine(GlobalPosition, neighbour.GlobalPosition, PathDebugColor, 0.2f);
        }
    }
}
